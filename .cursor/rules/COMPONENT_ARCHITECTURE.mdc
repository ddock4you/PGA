---
alwaysApply: true
---

- **요약**
  - detail routes (`/dex/[id]`, `/moves/[id]`, `/abilities/[id]`) 기준으로 데이터를 서버 컴포넌트(`fetchFromPokeApi`, `loadDexCsvData`)에서 가져온 뒤, client components는 `props` 또는 `DexCsvDataProvider` context만 활용합니다.

### 1. 개요

- 이 문서는 **컴포넌트 레벨 / 폴더 구조 / 파일 분리 기준**에 대한 단일 기준(Single Source of Truth)이다.
- 디자인 토큰/스타일 규칙은 `DESIGN_SYSTEM.mdc`, 화면 패턴은 `UI_PATTERNS.mdc`, 상태 설계는 `STATE_MANAGEMENT.mdc`를 함께 참고한다.

---

### 2. 컴포넌트 레벨 & 폴더 구조

- **`src/components`**

  - 재사용 가능한 **기본/패턴 컴포넌트**를 둔다.
  - 특징:
    - 순수 UI 전용: **props만 받아서 렌더링**하고, 도메인 지식/데이터 로딩/전역 상태 접근을 포함하지 않는다.
    - 공통 레이아웃, 카드 레이아웃, 필터 바, EmptyState 등 **도메인에 중립적인 UI 패턴**을 포함할 수 있다.

- **`src/components/ui`**

  - shadcn/ui에서 생성된 **저수준 UI 컴포넌트들**(예: `Button`, `Input`, `Card` 등)을 둔다.
  - 특징:
    - 디자인 시스템의 기반 요소로 사용하며, 가능한 한 이 레벨에서만 직접 수정한다.
    - 이 레벨의 컴포넌트는 보통 도메인 지식을 전혀 갖지 않는다.

- **`src/features`**
  - **도메인/기능 컴포넌트**를 둔다. (예: 검색, 도감, 퀴즈 등 기능 단위)
  - 폴더 구조 예:
- `src/features/search` (통합 검색 기능)
  - `components/` - SearchLandingForm (통합 검색 입력 UI)
  - `api/` - unifiedSearchIndexApi (CSV 기반 인덱스), searchIndexApi (기존)
  - `hooks/` - useUnifiedSearchIndex (통합 검색), useSearchIndex (세대별)
  - `types/` - unifiedSearchTypes (통합 검색 타입)
  - `utils/` - nameMappingUtils (이름 매핑), searchLogic (검색 알고리즘)
- `src/features/training` (배틀 트레이닝 퀴즈 기능)
  - `api/` - quizData.ts (CSV 기반 퀴즈 데이터 로딩, QuizPokemon/QuizMove 인터페이스)
  - `components/` - QuizStartScreen(조합), start/*(선택/옵션 UI), QuizQuestionCard, `attackTypeQuiz/*`, `pokemonTypeQuiz/*`, QuizPlayScaffold, QuizChoiceGrid, QuizResultFooter 등
  - `contexts/` - QuizContext.tsx, types.ts (Context API 기반 상태 관리)
  - `hooks/` - useQuizGenerator(트리거), useQuizNavigation, useQuizOptions, useTypeAnswerSelection 등
  - `utils/` - generators/* (순수 문제 생성 로직)
  - `_legacy/` - 현재 플로우에서 사용하지 않는 이전 구현 보관
- `src/features/generation`
  - `components/`
  - `constants/`
  - `types/`
- `src/features/dex`
  - `components/`
  - `contexts/`
  - `types/`
- `src/features/moves`
  - `components/` - 기술 리스트 컴포넌트들
- `src/features/abilities`
  - `components/` - 특성 리스트 컴포넌트들
  - `utils/` - localization.ts (특성 이름 현지화 유틸리티)
- `src/features/items`

  - `components/` - 도구 리스트 컴포넌트들
- `src/features/pokemonTypes`
  - `model/` - typeChart.ts (세대별 타입 상성 규칙), typeData.ts (정적 타입 데이터 생성)
  - `hooks/` - useAllTypes (정적 타입 데이터 제공), useTypeChart (타입표 선택/저장)
  - `components/` - 타입 상성표 UI (TypeChartViewer/TypeChartPlayground 등)
  - `utils/` - typeEffectiveness.ts (타입 상성 계산), typeEffectiveness.test.ts

### 2.1 Public API (index.ts) 규칙

- 폴더 단위로 외부에 공개할 API가 필요한 경우 `index.ts`를 둘 수 있다.
- 원칙:
  - `index.ts`는 **명시적 named export만 사용**한다. (`export { foo } from './foo'`)
  - `export *`는 지양한다. (의존 그래프 확장/번들 비용 증가 위험)
  - 외부에서 특정 파일만 필요한 경우에는 `index.ts`를 거치지 않고 **직접 import**를 허용한다.

- **더보기 기반 리스트 컴포넌트들**
  - `src/hooks/useLoadMore.ts` - 더보기/페이징 상태 관리 훅
  - `src/hooks/useListRestoration.ts` - 리스트 상태 복원 훅 (페이지/스크롤 복구)
  - `src/lib/listState.ts` - 세션 스토리지 기반 리스트 상태 관리 유틸리티
  - `src/components/ui/load-more-button.tsx` - 더보기 버튼 UI 컴포넌트
  - `src/components/ReactQueryProvider.tsx` - 데이터/쿼리 프로바이더 (사용 중인 경우)
- 원칙:

  - 해당 기능에 필요한 API 호출, 데이터 로딩 래퍼, 커스텀 훅, 타입 정의를 **기능 폴더 근처에 함께 배치**한다.
  - 다른 기능에서 재사용 가능한 순수 UI 조각은 `src/components`로 끌어올리는 것을 검토한다.

- **Server-only API 모듈 규칙**
  - `fetch`/서버 전용 유틸처럼 **클라이언트에서 import되면 안 되는 코드**는 `*.server.ts`로 만든다.
  - 해당 파일 최상단에 `import "server-only";`를 추가해 잘못된 import를 조기에 차단한다.
  - feature에서 공개 API가 필요하면, 클라이언트용 `index.ts`와 별도로 서버 전용 `index.server.ts`를 둬서 import 경계를 명확히 한다.
  - server-only 모듈에서 **타입만 export**하는 패턴은 지양한다.
    - 이유: 타입 import를 하려다(또는 자동 import로) 클라이언트에서 server-only 모듈을 끌고 오는 실수를 유발한다.
    - 권장: 타입은 `src/features/<feature>/types/*`로 분리하고, server-only 모듈은 함수만 export 한다.
  - 테스트 러너(Vitest 등)에서 `import "server-only";` 해석이 실패할 수 있으므로, 프로젝트 설정에서 alias/stub로 처리한다.

- **`src/app` (App Router)**
  - 라우트 단위 엔트리(기본: 서버 컴포넌트)를 둔다.
  - 역할:
    - URL → 라우트 매핑
    - 서버에서 데이터 로딩/조합 후, 필요한 최소 단위만 Client Components에 props/context로 전달
    - 라우트 단위 로딩/에러 UI 제공
    - Client UI 컴포넌트는 가능하면 `src/features/*`에 두고, `src/app`에는 라우트 조합만 남긴다. (예: `src/features/moves/components/MoveDetailClient.tsx`)
  - 파일 패턴:
    - 엔트리: `src/app/<segment>/page.tsx`
    - 로딩: `src/app/<segment>/loading.tsx`
    - 에러: `src/app/<segment>/error.tsx`
    - 404: `src/app/<segment>/not-found.tsx`
  - 라우트 전용 코드가 필요한 경우(최소화 권장):
    - `src/app/<segment>/_components`, `src/app/<segment>/_hooks` 등 로컬 폴더를 둘 수 있다.
    - 재사용/도메인화 가능해지면 `src/features/<feature>`로 이동한다.

---

### 3. 도메인/페이지 컴포넌트 기본 원칙

- **한 문장 원칙**

  - 하나의 컴포넌트는 **“한 문장으로 설명 가능한 역할”**만 담당한다.
  - 예:
    - `PokemonDetailPanel`: “포켓몬 하나의 도감 상세 정보를 섹션 탭 구조로 보여준다.”
    - `SearchLandingForm`: “통합 검색 입력 UI를 제공한다.”
    - `SearchResultSection`: “검색어에 대한 포켓몬/기술/특성/도구 섹션을 묶어서 보여준다.”

- **서버 vs 클라이언트 경계(App Router)**

  - 서버 컴포넌트(라우트 엔트리/서버 섹션):
    - 데이터 로딩/조합/캐싱/재검증을 담당한다.
    - Client Components에는 상호작용에 필요한 최소 데이터만 내려준다.
  - 클라이언트 컴포넌트(`use client`):
    - 입력, UI 상태, 브라우저 API, 사용자 상호작용을 담당한다.
    - 가능한 한 props/context 기반 렌더링에 집중한다.

- **성능 최적화 원칙**

  - **컨텍스트 메모이제이션**: 컨텍스트 Provider에서 `value` 객체를 `useMemo`로 감싸고, action 함수들을 `useCallback`으로 메모이제이션하여 컨텍스트 소비 컴포넌트의 불필요한 리렌더링을 방지한다.
  - **필터/검색 최적화**: O(n²) 이상의 복잡도를 피하고, 맵 기반 O(1) 조회나 단일 루프 처리로 전환한다.
  - **useMemo 의존성 최적화**: 계산 비용이 높은 연산에 `useMemo`를 적용하고, 의존성 배열을 정확히 지정하여 불필요한 재계산을 방지한다.

- **섹션/카드 단위 분리**
  - 화면에서 **시각적으로 독립된 섹션/카드**가 보이면, 해당 단위를 별도 컴포넌트로 분리한다.
  - 예:
    - `PokemonDetailPanel`
      - `PokemonDetailHeader`
      - `PokemonDetailStatsSection`
      - `PokemonDetailTypeEffectivenessSection`
      - `PokemonDetailMovesSection`
      - `PokemonDetailEvolutionSection`
    - `SearchPage` (검색 결과 페이지)
      - `SearchSummaryHeader` (검색 요약)
      - `SearchResultSection` (카테고리별 결과)

---

### 3.1 사이드이펙트(동기화) 분리 원칙

- **원칙**
  - URL 파라미터 파싱/빌드, 전역 컨텍스트(예: Preferences)와의 동기화, 데이터 로딩 트리거 같은 **사이드이펙트 로직은 컴포넌트 본문에서 직접 처리하지 않고 훅으로 분리**한다.
  - UI 컴포넌트는 가능한 한 **props 기반 렌더링**에 집중하고, `useEffect`/`router.push`/스토리지 접근은 컨테이너 훅에서 담당한다.

- **권장 형태 (검색 예시)**
  - `src/features/search/hooks/useSearchQueryParams.ts`:
    - URL → `{ q, generationId, gameId }` 파싱, `{...} → queryString` 빌드
  - `src/features/search/hooks/useSyncSearchPreferences.ts`:
    - URL 상태와 Preferences 상태를 단방향/양방향으로 동기화(필요한 경우에만)
  - `src/features/search/hooks/useUnifiedSearchResults.ts`:
    - `{ index, query } → results` (가능하면 순수/메모이제이션 가능)

- **입력/하이라이트 안전성**
  - 사용자 입력을 정규식으로 처리해야 한다면 **반드시 escape**한 뒤 사용한다.
    - 예: 검색어 하이라이트의 `RegExp(query)` 직접 생성 금지(특수문자 포함 시 오류/오동작 방지)

---

### 4. 파일 분리 & 길이 기준

### 4.1 상수/헬퍼 중복 금지 & 네이밍 규칙

- **중복 금지(단일 소스 원칙)**
  - 동일한 의미의 상수/매핑/헬퍼 함수(예: 타입 영문-한글 매핑, 포맷터, 표시용 문자열 조합)를 컴포넌트 파일마다 복사해서 만들지 않는다.
  - 이미 공용 함수가 있으면 반드시 재사용한다. (예: `getKoreanTypeName`, `formatStat`)
  - 공용이 필요한데 아직 없으면, “한 곳”에만 추가하고 전부 그곳을 import 한다.

- **배치 규칙(어디에 두나)**
  - 앱 전역에서 쓰이는 변환/매핑: `src/utils/*` (예: 타입/스탯/분류 라벨)
  - 특정 feature에서만 쓰이는 표시/도메인 규칙: `src/features/<feature>/utils/*`
  - 특정 섹션(예: moves 서브트리) 전용이면, 해당 트리 내부 `utils/*`에 둔다.
  - 여러 feature가 공통으로 쓰는 **타입 정의**(예: PokéAPI `NamedAPIResource` 같은 범용 타입): `src/types/*`
  - 여러 feature가 공통으로 쓰는 **상수/유틸**(예: 리스트 기본 페이지 크기): `src/lib/*`

- **feature 간 의존성(타입) 주의**
  - 공통으로 재사용되는 타입을 특정 feature(예: `src/features/generation`) 아래에 두고 다른 feature가 import 하는 방식은 결합도를 올릴 수 있다.
  - 범용 타입은 `src/types/*`로 올리고, feature는 해당 타입을 import 해서 사용한다.

- **네이밍 규칙**
  - `_LOCAL` 같은 접미사로 “중복 상수”를 만들지 않는다.
  - 매핑 객체를 직접 소비하기보다, 가능한 함수 형태로 감싼 API를 제공한다.
    - 예: `getKoreanTypeName(typeName)` (O)
    - 예: `TYPE_NAME_TO_KOREAN[typeName]` (X: 호출부 중복/분산 유발)
  - 변환 함수는 `getXxx`, `formatXxx`, `toXxx` 형태로 명확히 이름을 붙인다.
  - CSV 기반/서버 전용 등 “데이터 출처/제약”이 있으면 이름에 드러낸다.
    - 예: `getKoreanPokemonNameFromCsv`, `*.server.ts`

- **파일 길이 기준**

  - 하나의 파일이 **150줄 이상**이 되기 시작하면,
    - 시각적으로/역할상 독립된 섹션 단위로 **새 컴포넌트로 분리하는 것을 검토**한다.

- **상태/props 복잡도 기준**
  - `useState`/`useReducer`/데이터 로딩 훅 등 훅이 한 컴포넌트 안에 과도하게 많아지면,
    - 역할이 다른 부분을 상위/하위 컴포넌트로 나누는 것을 우선 고려한다.
  - props 개수가 너무 많아지면:
    - 의미 단위로 묶인 객체 props(`filters`, `summary` 등)로 재구성하거나,
    - 책임이 다른 경우 별도 컴포넌트로 분리한다.

---

### 5. 변형(variant) 관리 규칙

- **단순 스타일/크기 차이**

  - 예: `compact` / `default` 카드, 버튼 크기 등.
  - 처리 방법:
    - `variant`, `size` 등의 props로 처리하고, 내부에서 Tailwind 클래스/스타일만 다르게 적용한다.

- **레이아웃/구성이 크게 다른 경우**
  - 예:
    - 도감 페이지용 `PokemonCard` (정보 많음)
    - 검색 자동완성용 `PokemonCard` (작고 최소 정보만)
  - 처리 방법:
    - **별도 컴포넌트**로 분리 (`DexPokemonCard`, `SearchPokemonItem` 등 역할이 드러나는 이름 사용).
    - 공통 레이아웃/스타일이 있다면 작은 프레젠테이션 컴포넌트(예: `PokemonCardBase`)로 공유한다.

---

### 6. 상태/데이터 & 하위 폴더 규칙

- **기능 단위(`src/features`)**

  - 공통 원칙:
    - `api/`: 해당 기능에서 사용하는 API 래퍼, fetch 함수 등.
    - `hooks/`: 기능 전용 커스텀 훅 (`usePokemonList`, `useSearchIndex` 등).
    - `types/`: 기능 영역에서 공통으로 사용하는 타입 정의.
  - 페이지/도메인별로 공통적으로 사용하는 로컬 상태/데이터 래퍼는
    - `src/features/<feature>/api`
    - `src/features/<feature>/hooks`
    - `src/features/<feature>/types`
      에 배치한다.

### 6.1 Provider 스코프(적용 범위) 원칙

- **원칙**
  - Provider(예: Preferences, DexCsvData)는 “전역”으로 두기 전에, **어떤 라우트/기능에서 필요한지**를 기준으로 적용 범위를 결정한다.
  - 전역에 둘수록 편하지만, 의존성이 커지고 관심사가 섞이기 쉬우므로 다음 기준을 우선한다.

- **권장 기준**
  - **전역 Provider**: 테마/Preferences처럼 거의 모든 화면에서 필요한 것
  - **라우트 그룹 Provider**: 특정 섹션(예: 상세 페이지 그룹)에서만 필요한 것
  - **기능 Provider**: 특정 기능 화면(예: 트레이닝 퀴즈)에서만 필요한 것

---

### 6.2 App Router 에러/로딩 처리 원칙

- **원칙**
  - 전역 ErrorBoundary만으로 처리하지 말고, Next.js App Router의 라우트 단위 파일을 우선 사용한다.
    - `src/app/error.tsx`, `src/app/not-found.tsx`, `src/app/loading.tsx`
    - 필요 시 `src/app/<segment>/error.tsx`, `src/app/<segment>/loading.tsx`로 세분화
  - “어느 화면에서 실패했는지”를 라우트 단위로 드러내고, 로딩/에러 UI는 페이지 조합 레이어(`src/app`)에서 제공한다.

---

### 6.3 Feature 서브도메인 폴더 규칙 (권장)

- **목표**: 한 feature 안에서 특정 서브도메인(예: `pokemon/moves`)이 커질 때, UI/타입/유틸/훅을 한 덩어리로 유지하면서도 레이어 경계를 지킨다.

- **규칙**
  - `components/` 트리는 “UI leaf”로 취급한다.
    - `hooks/`, `api/`, `utils/`, `types/`에서 `components/**` 아래의 `types/utils/constants`를 import 하지 않는다.
    - 여러 레이어에서 재사용되는 타입/유틸/상수는 `src/features/<feature>/<subdomain>/{types,utils,constants}`처럼 feature 루트 쪽으로 올린다.
  - 서브도메인 단위로 묶을 때는 feature 내부에 한 단계 폴더를 두는 것을 우선한다.
    - 예: `src/features/pokemon/moves/components/*`
    - 예: `src/features/pokemon/moves/types/*`
    - 예: `src/features/pokemon/moves/utils/*`
    - 예: `src/features/pokemon/moves/hooks/*` (서브도메인 전용 훅은 가능하면 서브도메인 아래에 둔다)

- **라우트 단위(`src/app`)**
  - 라우트 전용 상태/훅/컴포넌트가 필요한 경우(최소화 권장):
    - `src/app/<segment>/_hooks`, `src/app/<segment>/_components`
  - 전역/도메인에 가까운 것은 `features` 레이어로 끌어올린다.

상태의 성격(전역 vs 페이지 로컬)과 데이터 출처(서버 vs 클라이언트)에 관한 보다 자세한 원칙은 `STATE_MANAGEMENT.mdc`를 따른다.

---

### 7. 사용하지 않는 패턴 (현재 기준)

- **Compound Component 패턴(예: `Parent.SubComponent`)**
  - 현재는 사용하지 않는다.
  - 대신:
    - 파일은 섹션 단위로 나누되,
    - import 시에는 명시적인 이름을 사용한다. (예: `import { PokemonDetailHeader } from './PokemonDetailHeader'`)
  - 나중에 필요성이 명확해질 경우, 이 문서에서 허용/금지 기준을 다시 정의한 후 도입한다.

---

### 8. 다른 문서와의 관계

- **`DESIGN_SYSTEM.mdc`**

  - 타이포그래피, 여백, 컬러, 버튼/카드/배지 등의 **시각적/스타일 규칙**을 정의한다.
  - 컴포넌트 레벨/폴더 구조에 대한 내용은 이 문서(`COMPONENT_ARCHITECTURE.mdc`)를 따른다.

- **`UI_PATTERNS.mdc`**

  - `/`, `/search`, `/dex`, `/training` 등의 **페이지/섹션 레이아웃 패턴**을 정의한다.
  - 페이지/기능 컴포넌트가 어떤 패턴을 사용할지는 이 문서를 참고하고,
    실제 폴더/파일 구조는 `COMPONENT_ARCHITECTURE.mdc`를 따른다.

- **`STATE_MANAGEMENT.mdc`**

  - 서버/클라이언트 경계, 전역 상태, 페이지 로컬 상태 등 **상태 관리 전략**을 정의한다.
  - 상태/데이터 훅의 위치/폴더 구조는 이 문서의 규칙(섹션 6)을 따른다.
